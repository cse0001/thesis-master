\chapter{绪论}

本章的主要内容与学校提供的Word模板中内容一致，图片与表格均采用原始设定大小，%
主要是为了说明格式的统一。%
但是，\LaTeX{}的一些禁则，专业排版的能力，对公式及文献的处理都是得天独厚的，%
我们不必刻意去追求与Word的完美匹配。而且你将会发现，用\LaTeX{}书写论文的美！ %

\section{研究背景及意义}
兼容性问题是计算机软件工程领域的一个研究热点，它通过依赖冲突检测或程序分析等方式检测第三方库和第三方库、软件和第三方库之间的兼容性。第三方库 (又称第三方依赖或软件包) 是一种重要的可复用软件资源， 在一定条件下， 可以独立于其他第三方库进行安装和删除[1]。软件开发过程中调用第三方库是一种提高开发效率的普遍做法， 特别是随着现代信息技术的迅速发展， 软件规模不断增加， 软件开发对第三方库的依赖也在不断增加。已有研究工作表明一个项目直接依赖于多个不同的库[2]。此外， 由于第三方库之间存在依赖关系，一个项目往往会被隐蔽式的加入更多的依赖关系，导致依赖更多的库[2-5]。

第三方库的使用大大提升了软件开发效率，但也给软件开发带来了潜在的风险。当加载的第三方库无法覆盖所在项目或其他第三方库的必需特性(例如，方法) 时，就会发生兼容性问题。目前对兼容性问题的解决方式多为开发人员借助经验知识去处理，会消耗大量的时间和人工成本。运行过程中的报错信息在多数情况下不足以支撑开发人员找到问题根源，并且由于第三方库之间存在复杂的调用关系，更改某一第三方库同时可能引起其他第三方库的不适用，这些问题增加了检测和解决兼容性问题的难度，同时兼容性问题会伴随如下特点：难以重现问题出现的场景、编译器提示的问题报告中描述信息不够清晰、第三方库代码缺失、第三方库代码复杂难以调试等。这些问题在开发过程中给开发人员带来了巨大挑战。

随着现代软件开发的发展，各类软件生态的通用做法是将越来越多第三方库打包（第三方包）并维护在一个中央仓库，以便开发者下载和安装。为了帮助开发者处理第三方包间复杂的依赖关系，避免兼容性问题，软件生态提供了包管理器进行第三方包的下载，删除，依赖解析等。例如，在编程语言社区中，pip作为Python语言的包管理器，管理着接近五十万个包[6]，npm作为JavaScript语言的包管理器，管理着超过三百万包。同样，在操作系统发行版社区中，apt作为Ubuntu系统的包管理器，管理着超过八万deb包，dnf作为Fedora的包管理工具，管理着超过七万rpm包。

包管理器设计的主要目标是在其软件生态内部进行正确的依赖解析，即避免引入的第三方包间发生不兼容问题。为了促进这一目标的达成，大量研究致力于提升对于第三方包的依赖管理能力。对于各种编程语言软件仓库，一系列工作[7-10]针对增强python包管理器的依赖解析和兼容性检测，部分研究[11-13]针对JavaScript软件仓库的依赖管理。还有部分研究[1,14-16]针对操作系统发行版社区软件仓库中的第三方包兼容性问题。然而，系统内单个软件仓库内部的包兼容性无法保证系统整体的包兼容性。开发者在实际软件开发中，往往需要结合多个软件仓库的资源，这就导致了一个研究空白：如何有效地分析和检测多个软件生态共同作用下的兼容性问题。而现有包管理器和研究工作大多致力于提高特定软件仓库的包管理和兼容性检测能力，这些努力通常局限于单一的软件生态，无法有效检测和修复多个软件生态共同影响下的包兼容性问题。

因此，针对这一研究空白，探究一种有效分析和检测跨软件生态的兼容性问题的方法是十分有必要的。这不仅对于提高软件系统的稳定性和性能有着直接影响，还有助于减轻开发人员的工作负担，优化开发流程，降低因兼容性问题带来的风险和成本。


\section{相关研究现状}
\subsection{依赖冲突检测方法}
现有大量工作致力于单个软件生态中的依赖冲突检测，并尝试对依赖冲突问题生成崩溃信息的堆栈跟踪。EVOSUITE[17，18]是一个面向Java语言的开源工具，采用遗传算法为给定的目标类生成测试用例集，通过自定义的适应度函数以及设计的交叉运算和变异函数, 加速搜索过程, 指导第三方库被调用方法的测试用例的生成, 提高对第三方库方法间冲突检测的有效性和效率使用测试的方式提高对第三方库方法间冲突检测的有效性和效率。Wang等人[19]提出的RIDDLE基于静态分析，构造控制流依赖关系，对依赖关系生成变体进行测试，是EVOSUITE的改进。

Patra等人[12]提出的ConflictJS针对的是JavaScript语言中，由于第三方库共享相同的全局命名空间导致的依赖冲突问题。这类问题的出现，是由于不同库对同一命名空间进行写操作。ConflictJS动态地分析单个第三方库写入全局命名空间的位置，基于库的全局写入位置进行匹配，进一步比较库中方法的行为，当且仅当该方法发现有不同行为时，报告依赖冲突问题。Wang等人[10]提出的Watchman是一个持续监测 PyPI 生态系统依赖冲突的工具。通过收集每个第三方包的metadata (元数据) 并进行广度优先搜索，为项目依赖的第三方包构建完整的依赖调用关系图。依赖关系图的实际呈现形式为有向无环图，图中的节点代表第三方库，节点间的有向边代表着两个包之间的依赖关系，有向边箭头指向的节点代表被依赖的第三方包。对依赖关系图中有多个有向边所指向的节点，即为被多个包同时依赖的第三方包; 分析其传入的边的集合，对边之间约束的版本关系进行匹配分析，若传入边之间约束的交集为空，证明存在依赖冲突问题。

Huang等人[20]通过分析项目代码中各个模块的第三方包版本，检测项目中的依赖冲突问题。遍历所有模块所依赖的包版本，对每一个包进行版本匹配，分析这些包的版本是否一致，如果不是，那么检测到了包版本不一致的问题，并报告其所影响的模块。根据匹配结果，按照最少改动的原则，进行版本的推荐Mancinelli等人[21,22]提出的EDOS是基于形式化方法，对第三方包中的依赖冲突关系进行解析，将第三方包的可安装性问题转化为约束求解问题，并设计为自动化的检测工具。从操作系统发行版的角度，降低包之间冲突出现的频率，提高了发布的第三方包的稳定性。
\subsection{兼容性问题检测方法调研}
对于项目或第三方包之间的兼容性问题，现有方法总体上基于匹配的思想，对比不同版本第三方包的运行结果，或构建项目方法的依赖调用图或抽象语法树,进行调用关系的对比匹配。Foo等人[23]提出的JTEXPERT是一种自动化软件测试数据生成方法，它实现了单元类测试的高代码覆盖率。其核心思想是基于遗传算法，通过类实例生成器和种子策略来优化搜索，并通过静态分析方法从搜索空间中删除不相关的输入变量加速搜索过程，其生成的测试数据可用于检测不同版本的第三方包和调用关系不一致的行为。

一种常见的兼容性问题表现为，开发人员期望加载的版本和实际加载的版本中,使用的方法具有相同的签名，但是两者程序运行行为不一致。Wang等人[24]提出的SENSOR使用遗传算法来检测API之间的兼容性。SENSOR首先从源代码中提取每个对象的构造函数和API调用的上下文，并利用它们来构造类实例池和API参数池；基于GUMTREE[25]迭代检测得到的代码差异，在细粒度级别上识别异构的冲突API对。SENSOR认为异构的冲突API对可能会导致兼容性问题，SENSOR方法将类实例调用的种子策略与EVOSUITE[17]结合起来，生成测试用例集来触发相关的库API，并检查它们在不同版本中的行为是否一致。

PYCOMPAT[26]运用静态分析的方法，检测由Python第三方库中API更改引起的兼容性问题。具体来说，是为了检测由API重命名和参数重命名引起的问题，其检测分为两个阶段：第1阶段抽取第三方库中的API更改信息，当API的更改信息无法进行自动化抽取时，采用人工抽取；对抽取出的信息，构建知识库，第2阶段将 API 知识库作为输入，并对给定的Python源文件执行静态分析，构建抽象语法树(AST)，遍历AST以获得框架中定义的API的调用，进而通过定义的匹配规则来检查对API的调用，是否使用了改进的API，定位兼容性问题。
Foo等人[27]运用静态分析方法来检查第三方库在升级后,是否引入了不兼容库中API的方法。其首先构建程序的库调用图，利用Myers算法提取升级前后库中API的差，于版本的更改，可能直接跳跃多个版本。算法计算每个相近版本间API的差异，进而得到最终的差异结果，并结合依赖调用图来判断是否发生了不兼容的更改。通过解析配置文件，对改动最少的版本进行推荐。
\subsection{第三方包演化研究}
兼容性问题主要体现于API之间的不兼容，调研第三方包演化过程中API兼容兼容性问题的相关研究工作，可以为检测兼容性问题提供参考性意见。Meng 等人[28]提出的HiMa基于历史的匹配方法来识别和理解Java框架的API演变。Hora 等人[29]提出的APIwave是一个基于匹配规则，识别跟踪API流行度和迁移的大型工具，与HiMa的不同点在于，APIwave的使用范围更广，可以跟踪API的流行程度。APIwave与HiMa对第三方库的对比，可以帮助开发人员快速了解两个版本之间的差异，进而修改自己的代码。当开发人员面临第三方包之间的兼容性问题时，可以使用此工具快速发现新版本中产生变更的API，来修改本地项目代码，减少兼容性问题的发生。

Ponomarenko等人[30]提出了一种在二进制级别的、可适用于多种语言的、自动检测第三方库的向后兼容性问题的新方法。此方法除了分析组件二进制文件中的符号外，还可以通过比较从组件头文件中获得的函数签名和类型定义，来验证向后兼容性问题。Jia等人[34]同样提出了二进制级别的第三方包不兼容更改检测工具，可以检测第三方包演化过程前向和后向不兼容问题。这种二进制级别的兼容性检测相比于API级别的检测更细粒度也更准确。

NoRegrets[31]是一个回归测试工具，可以用来确定Javascript第三方包更新后是否影响了有关API的使用，并对更新前后API的兼容性进行对比。NoRegrets+[32]通过分析Javascript第三方包被其他第三方包复用的情况，自动判断第三方包的更改是否影响公共API的使用，并自动生成测试用例，来查找库中的破坏性更改。Lamothe等人[33]基于文档和历史代码更改信息，对Android中API的迁移升级方法进行检测。

综上，现有相关工作主要聚焦于单个软件生态中的兼容性问题的分析、检测和解决，对于跨软件生态的兼容性问题尚未由成熟的解决方案。因此，探究一种有效分析和检测跨软件生态的兼容性问题的方法，具有相当的研究意义和实践意义。

\ignore{
\begin{table}[htp]
	\centering
	\begin{minipage}[t]{0.8\linewidth} % 如果想在表格中使用脚注，minipage是个不错的办法
		\caption[表 1.1 名称]{}
		\begin{tabular*}{\textwidth}{lp{10cm}}
			\toprule[1.5pt]
			{\hei 列1} & {\hei 列2} \\
			\midrule[1pt]
			&  \\
			& \\
			& \\
			& \\
			& \\
			& \\
			\bottomrule[1.5pt]
		\end{tabular*}
	\end{minipage}
\end{table}
}

\section{研究内容和贡献}
目前，许多编程语言和操作系统社区常常维护第三方包软件库并提供相应的包管理工具，以建立自己的软件生态。这些工具通常都经过精心设计，以处理生态软件库内的依赖关系，而不考虑库间的依赖关系。现有的相关研究也只关注了单个软件生态内部第三方包之间发生的兼容性问题，忽略了多个软件生态共同影响的第三方包兼容性问题。为了弥补这一研究空白，本研究从两方面研究CC问题：（1）CC问题的特征和根本原因是什么？（2）如何自动化预测、检测和修复CC问题？具体而言，本研究以Python语言和Ubuntu系统两个影响广泛的软件生态为代表，深入分析研究Ubuntu系统上不同仓库中Python第三方包出现的CC问题，总结CC问题的触发模式、故障症状和根本原因，在此基础上，本研究设计并实现对应的自动化检测工具，在解决Python语言和Ubuntu系统间的CC问题的同时，也对其他软件生态间的类似问题的研究起到启发和指导作用。
\subsection{跨软件生态兼容性问题实证研究}\label{1.3.1}
在Ubuntu系统中，用户管理Python第三方库最普遍的做法是利用包管理工具，包管理工具会在系统内维护一个本地仓库存储从对应软件源中安装的第三方包，其中最为广泛使用的第三方包管理工具是apt和pip。Apt是Ubuntu系统的官方包管理工具，可以帮助用户安装、更新和卸载各种语言的第三方包，其中包括数千个Python第三方包。Pip是Python语言最常用的包管理工具，其软件源是PYPI，存储了数百万个Python第三方包。对于用户而言，使用apt安装Python包可以确保系统级别的包依赖关系得到正确处理（例如Python第三方包和一些二进制库之间的兼容性），而使用pip则可以安装种类更多版本更丰富的Python。因此，用户在实际开发中，往往需要同时使用apt和pip安装Python第三方包，从而兼顾系统的稳定性和开发的灵活性。然而，本研究发现系统内不同软件仓库中的第三方包会发生CC问题，并且CC问题在包管理工具安装第三方包时不会被检测到。那么，CC问题为什么会发生以及CC问题为什么现有的包管理工具无法检测到呢？

本研究从两方面入手分析原因，首先，从Python包安装策略来看，apt和pip的策略迥然不同，apt只检查自身仓库依赖关系并安装对应操作系统固定版本的包，pip会检查系统内全部的包并安装符合约束的最新版本的包，这会导致apt仓库和pip仓库中安装同一个Python第三方包的不同版本。其次，从Python解释器导入Python包策略来看，解释器会按照包名根据固定顺序在系统各个包仓库中搜索Python第三方包，如果找到则不搜索其他目录，这会导致解释器会从不同仓库中导入一个包和它的依赖包。基于上述分析，本研究进一步总结了CC问题的特征，包括三种触发模式和四种故障症状。

基于最常见的一种触发模式，本研究通过大规模的测试和分析，研究了CC问题对于Ubuntu20.04系统的影响。具体而言，本研究首先从Ubuntu20.04系统的apt软件仓库中的全部Python包出发，结合依赖关系和PyPI软件仓库中的Python包，构建了23866个可能出发CC问题的包安装指令序列。然后，本研究逐一测试安装序列，发现由1692个序列会发生CC问题.本研究收集这些问题的错误信息以构建一个CC问题数据集，这些CC问题导致原本可以正常导入的Python第三方包导入失败。在实际用户环境中，这些失败可能会导致正常运行的系统软件崩溃，并且CC问题发生时的错误信息和传统包兼容性问题类似，导致用户难以排查并解决问题。基于上述发现，本研究进一步总结了CC问题的根本原因，为后续设计自动化解决工具提供了基础。
\subsection{跨软件生态兼容性问题的预防、检测和修复}
为了提升Ubuntu系统中的Python依赖包治理能力，本研究致力于自动化解决CC问题，本节研究并设计了一种自动化工具\tool{}来预测、检测和修复CC问题。对于预测CC问题，当用户执行安装命令时，Hera
预测这些命令是否会导致CC问题。对于检测CC问题，\tool{}会扫描用户系统中安装的所有Python包，并检测是否存在CC问题。对于修复CC问题，当检测到CC问题时，\tool{}会提供修复建议，防止用户出现故障。
由于这三种情况都在用户的生产环境中工作，因此在部署\tool{}时，开销应至关重要。在这方面，\tool{}的核心在于离线建立一个跨软件生态的兼容性数据库，然后在线预测、检测和修复CC问题。离线阶段和在线阶段都具有挑战性：
\begin{itemize}
	\item \textbf{构建跨软件生态的兼容性数据库非常困难。}软件生态的软件仓库可能包含大量软件包（例如，pip目前管理着近五十万个软件包），其中大多数软件包具有较长的演化历史。这些软件包不断进行异步演化，因此数据库也必须相应地不断更新。来自不同仓库的软件包之间的依赖关系组合将是巨大的。考虑所有可能的软件包版本组合几乎是不可能的。
	\item\textbf{ 预测、检测和修复CC问题并非易事。}每个软件生态的软件仓库都有其独特的管理工具，并采用不同的安装策略和目录结构。安装软件包时，若apt在其自身的安装目录中找不到该软件包，则会安装特定版本，而pip则会在系统级目录中找不到该软件包时安装最新版本。导入软件包时，Python解释器会按照预定义的顺序依次检查所有目录。CC问题涉及以上三者（即 apt、pip和Python解释器）之间的交互，使其难以预测、检测或修复。
\end{itemize}

为了解决第一个挑战，我们基于章节~\ref{1.3.1}对于CC问题的分析研究，发现每个CC问题都包含一个应用包和一个库包。应用包通常托管于apt仓库中，而库包则同时托管于apt和pip仓库中（应包用和库包是相对概念，因为一个应用包本身可能是另一个应用的库包。这一发现揭示了两种关系：a）应用包与托管于apt的库包是兼容的；b）托管于apt的库包与pip中的同名库包不兼容。鉴于此，\tool{}在兼容性数据库中创建了两个表：
\begin{itemize}
	\item \textbf{依赖表}：对于apt仓库中的每个应用包，该表收集其对apt仓库中各个库包的API使用情况。
	\item\textbf{ 兼容性表}：对于apt仓库中的每个库包，该表收集其与pip仓库中不同版本的同名库包的API兼容性。
\end{itemize}
这两个表提供了有关CC问题的充分信息，并且其规模是可接受的，因为apt仅管理约3,319个特定版本的Python软件包。当操作系统发行版发布时，\tool{}会构建一个新的数据库。之后，\tool{}会增量地获取pip仓库中的最新软件包版本。

针对第二个挑战，本研究提出了系统级软件包依赖图（S-PDG），用于描述apt、pip和Python解释器之间的交互关系。S-PDG 包含用户系统中所有 Python 软件包的依赖关系。为实现这一点，\tool{}首先分别构建了由 apt 和 pip 安装的软件包的两个依赖图。我们将这两个依赖图称为仓库级软件包依赖图（R-PDG）。之后，\tool{}根据 Python 解释器的导入规则将两个 R-PDG 合并为一个 S-PDG。当两个版本的软件包出现在不同的 R-PDG 中时，\tool{}会查询兼容性表，以确定这些版本之间是否存在破坏性 API。如果存在破坏性 API，\tool{}会进一步查询依赖表，以检查系统中是否有使用这些破坏性 API 的应用程序包。如果有，Hera 会报告一个 CC 问题。最终，Hera 可以根据 R-PDG 中的依赖关系提供修复建议，这些依赖关系被认为是兼容的，因为它们仅包含仓库内的依赖关系。在预测场景中，Hera 会试运行安装命令，然后将待安装的软件包临时添加到 S-PDG 中。

本研究对于\tool{}进行了广泛的实验评估，在章节~\ref{1.3.1}构建的CC问题数据集的23866个序列上，\tool{}检测到 3689 个 CC 问题，其精确度为 90.5\%。这些问题可以覆盖数据集中 1,692 个问题中的 93.7\%。为评估分析不兼容 API 变更的有效性，本研究手动检查了结果，发现其精确度和召回率分别为 91.1\% 和 98.2\%，置信水平为 95\%，误差范围为 5\%。本研究还从 GitHub 和 Stack Overflow 收集了 27 个实际的 CC 问题，并重现了其中的 26 个。\tool{}能够检测到这 26 个问题中的所有问题，并提供准确的原因和修复建议。
\subsection{贡献}
总结而言，本文的主要贡献如下： 
\begin{itemize}
	\item \textbf{新的研究问题。}本研究是首个研究跨软件生态兼容性问题的工作。本研究定义了CC问题，并从Python的角度对其进行了研究。该问题可扩展至其他编程语言，本研究对于其他软件生态中类似问题的研究起到了启发和引导作用。
	\item \textbf{新型工具实现。}本研究设计了\tool{}，这是一种新型工具，可离线构建跨软件生态兼容性数据库，并在线预测、检测和修复 CC 问题。\tool{}能够分析整个软件仓库，并在用户的生产环境中保持轻量级。
	\item \textbf{广泛实验评估。}本研究对\tool{}进行了全面的评估，发现了\tool{}在 CC 问题检测中的精确度和召回率方面都具有良好的效果。\tool{}还能够检测并修复来自 GitHub 和 Stack Overflow 的实际 CC 问题。
\end{itemize}
\section{论文结构}
本文组织分为五个部分，每部分的内容具体如下：

\textbf{第一章 绪论。}本章阐述了研究背景、研究意义、研究内容和贡献、以及论文的组织结构。首先，通过分析当前第三方包依赖和兼容性管理的挑战和机遇，明确研究的背景和问题。接着定义研究的主要内容和贡献，最后总结整篇论文的结构和各章节的主要内容。

\textbf{第二章 相关工作。}

\textbf{第三章 跨软件生态的兼容性问题实证研究。}

\textbf{第四章 跨软件生态的兼容性问题预测、检测和修复。}

\textbf{第五章 实验与评估。}本章详细描述了实验设置、实验过程和实验结果的分析。首先介绍实验的设置，包括实验数据、实验放啊发和评估指标。然后通过大量实验，验证所提出的方法的有效性，并从多个角度分析实验结果。最后对实验结果进行深入的讨论。

\textbf{第六章 总结与展望。}本章总结了全文的主要研究内容和主要贡献，并对未来的研究方向进行展望。首先总结本文的主要研究发现和贡献，然后基于当前的研究现状和本文的研究结果，探讨未来可能的研究方向和挑战。最后对本文的内容进行梳理和总结。


