\chapter{跨软件生态的兼容性问题预测、检测和修复}
在本节中，我们介绍了\tool{}，该自动化工具旨在检测和预测 CC 问题，并为用户提供修复建议。
\tool{}的整体设计如图\ref{fig:overview}所示。
\begin{figure}[htbp] % use float package if you want it here
	\centering
	\includegraphics[width=5in]{overview2}
	\caption{\tool{}的整体设计图}
	\label{fig:overview}
\end{figure}
\tool{}主要包括离线和在线两个阶段。离线阶段构建了一个跨仓库兼容性数据库，包括两个主要表格：依赖表和兼容性表（见第 \ref{4.1}节）。在线阶段构建了一个系统级软件包依赖图（S-PDG），用于检测和预测 CC 问题，并提供修复建议（见第 \ref{4.2} 节）。

\section{构建兼容性数据库}\label{4.1}
由于 \tool{} 旨在用户的生产环境中工作，因此其性能开销至关重要。然而，在线分析所有应用软件包和库软件包之间的兼容性需要较高的开销。为了克服这一限制，我们基于第 \ref{3.3} 节中 CC 问题的特性，将应用软件包与库软件包之间的兼容性问题转化为同一库软件包在 apt 仓库和 pip 仓库中的兼容性问题。例如，在图 \ref{fig:command} 中，应用软件包 “amp” 与库软件包 “numpy” 之间存在 CC 问题。由于 “amp” 与库软件包 “numpy 1.17.4” 兼容，我们可以通过分析 “numpy 1.17.4” 与 “numpy 1.24.3” 的 API 兼容性以及 “amp” 是否调用了破坏性 API 来确定 “amp” 与 “numpy 1.24.3” 的兼容性。

为了实现这一目标，我们在离线阶段构建了一个跨仓库兼容性数据库，从而避免在线阶段进行复杂的程序分析。该兼容性数据库包含依赖表和兼容性表。对于 apt 仓库中的每个应用软件包，依赖表收集其在 apt 仓库中每个库软件包的 API 使用情况。对于 apt 仓库中的每个库软件包，兼容性表收集了其与 pip 仓库中同一软件包各个版本的 API 兼容性。构建过程首先从两个仓库索引的软件包中准备应用软件包和库软件包（见第 \ref{4.1.1} 节），然后通过 API 使用提取构建依赖表（见第 \ref{4.1.2} 节），最后通过兼容性分析构建兼容性表（见第 \ref{4.1.3} 节）。

\subsection{第三方包准备}\label{4.1.1}
首先，我们从 apt 仓库中收集了应用软件包。Ubuntu 20.04 维护了共计 3,319 个 Python 软件包。我们使用 apt 获取了所有软件包的源代码，以用于 API 使用情况的提取分析。接着，我们分析了每个应用软件包是否也存在于 pip 仓库中。pip 的中央仓库是 PyPI [18]，其中包含了超过 40 万个第三方 Python 软件包。具体而言，我们从 PyPI 中检索了每个软件包的可安装版本。如果存在可安装版本，我们将其视为库软件包，并使用 pip 下载该软件包的所有版本源代码。然而，由于两个中央仓库中的命名策略不同，同一个 Python 软件包可能在这两个仓库中有不同的名称。为了解决这个问题，我们获取了每个应用软件包的顶级模块名称，并使用该名称在 PyPI 中匹配软件包，从而避免遗漏。通过这种方式，我们共识别了 2,419 个库软件包及其在 PyPI 中的所有可安装版本。

由于这些库软件包在 PyPI 中异步不断地演进，数据库也需要相应地保持更新。然而，手动更新并不可行，因为它无法跟上 PyPI 更新的速度。为了解决这一问题，我们借助了 \textit{Libraries.io} [8]，该平台监控包括 PyPI 在内的 32个生态系统的仓库更新情况。基于此，我们可以增量获取最新的软件包版本，并及时更新兼容性数据库。

\subsection{依赖表构建}\label{4.1.2}
依赖表存储了所有应用软件包在 apt 仓库中库软件包的 API 使用情况。依赖表的存储格式如图\ref{fig:storage}所示。
\begin{figure}[htbp] % use float package if you want it here
	\centering
	\includegraphics[width=6in]{tables}
	\caption{依赖表和兼容性表示例}
	\label{fig:storage}
\end{figure}
数据分析过程分为以下两个步骤：
\begin{itemize}
	\item \textbf{步骤 1：分析 apt 仓库的内部依赖关系。}apt 仓库中的所有应用软件包都依赖于 apt 仓库中库软件包的预定义版本。因此，分析 apt 的内部依赖关系需要检索每个应用软件包所依赖的库软件包。然而，apt 软件包文档将依赖关系分为 \textit{Depends}、\textit{Recommends} 和 \textit{Suggests} 三类。\textit{Depends} 是确定性的依赖关系，但应用软件包也可能依赖于另外两类软件包。这使得仅通过文档难以准确确定依赖关系。为了解决这一问题，我们在干净的环境中安装了每个应用软件包，以获取准确的依赖关系，确保对 apt 仓库内部依赖关系的正确分析。
	\item \textbf{步骤 2：提取库软件包的所有 API 使用情况。}\tool{} 通过静态分析提取 API 使用情况。具体而言，对于每个应用软件包及其依赖的库软件包，我们首先遍历应用软件包的源代码文件，检查是否导入了该库软件包。如果导入了库软件包，\tool{} 会将代码解析为抽象语法树（AST），并扫描 AST 节点以检测该库软件包的 API 使用情况。如果检测到 API 使用情况，则将应用软件包、库软件包及其使用的 API 记录到依赖表中。如果未检测到，则说明该应用软件包与库软件包存在间接依赖关系，这种情况也会被记录到依赖表中。
\end{itemize}
\subsection{兼容性表构建}\label{4.1.3}
兼容性表存储了每个库软件包与 pip 仓库中同一软件包各版本之间的 API 兼容性。兼容性表的存储格式如图 \ref{fig:storage} 所示。如果库软件包的不同版本之间存在 API 不兼容的更改，\tool{} 会在兼容性表中记录它们之间的不兼容关系及所有不兼容的 API。为了实现这一目标，\tool{} 执行了以下两个步骤：
\begin{itemize}
	\item \textbf{步骤 1：API提取。}为了准确分析库软件包不同版本之间的兼容性，首先需要获取该库软件包各版本的所有 API。对于大多数静态编程语言，静态分析可以有效地提取软件包提供的 API。然而，Python 是一种动态编程语言，一些 API 由 Python 对象在运行时创建和修改，无法通过静态分析获取。为了解决这一问题，我们采用了动态分析与静态分析相结合的策略来提取 API，涵盖了类、函数（及其参数）和属性等。在动态分析中，我们使用 \textit{inspect} 模块在导入 Python 软件包后进行反射动态 API 提取。\textit{inspect} 模块能够动态访问活动对象的内部结构，从而提取由 Python 对象在运行时创建和修改的 API。此外，我们使用 \textit{parso} [13] 模块进行静态分析，以补充函数定义和其他信息的提取。
	\input{table/rules}
	\item \textbf{步骤 2：分析API不兼容更改。}准确分析库软件包不同版本之间的不兼容更改（IC）是 \tool{}有效性的保证。不兼容更改包括两种类型：前向不兼容更改（FIC）（例如，添加一个 API）和后向不兼容更改（BIC）（例如，移除一个 API）[33]。由于在 CC 问题中，apt 仓库和 pip 仓库中的库软件包版本顺序不一定是连续的，因此这两种类型的不兼容更改都可能导致软件包不兼容，并引发 CC 问题。作为不兼容更改分析目标的 Python 拥有灵活的语法，因此其 API 更改的复杂性远超 C++ 和 Java 等语言。因此，很难确定哪些 API 更改是属于不兼容的。
	
	为了解决这一问题，我们借鉴了现有研究 [56]，考虑了 前向不兼容更改 和 后向不兼容更改 两种类型，总结了七种不兼容更改模式，并设计了判定规则。这些模式和规则如表 2 所示，频率表示兼容性表中每种模式的占比。对于与 API 相关的更改，我们根据 API 提取步骤的结果检测 Python 程序中类、函数和属性的添加或删除。对于与 API 参数相关的更改，我们考虑了必选参数和可选参数的变动以及参数顺序的变动。值得注意的是，从必选参数变为可选参数（或反之）将由规则 3（4）检测到。我们将发生不兼容更改的 API 称为破坏性 API。兼容性表将存储每个不兼容更改的破坏性 API 信息，包括名称、参数、类型和更改模式等。

\end{itemize}

基于上述两个步骤，在 Ubuntu 20.04 和 Python 3.8.10 环境中，我们从 2,419 个库软件包的 47,387 个版本中提取了 62,552,811 个 API，并发现了 42,059,456 个API不兼容改变。

\section{预测、检测和修复CC问题}\label{4.2}
CC 问题涉及上述三个部分（即 apt、pip 和 Python 解释器）之间的交互，因此难以预测、检测或修复。为了解决这一挑战，我们提出了一个系统级软件包依赖图（S-PDG），用于描述 apt、pip 和 Python 解释器之间的交互关系。在本节中，我们主要解释如何构建 S-PDG（见第 \ref{4.2.1} 节），并将其与跨仓库兼容性数据库结合使用来检测 CC 问题（见第 \ref{4.2.2} 节）。我们还解释了如何通过模拟运行命令来预测 CC 问题（见第 \ref{4.2.3} 节）并为用户提供修复 CC 问题的建议（见第 \ref{4.2.4} 节）。
\subsection{构建S-PDG}\label{4.2.1}
首先，\tool{}会收集 系统本地apt 和 pip仓库中的Python第三方包并分析目录内部包依赖关系，构建两个仓库级软件包依赖图（R-PDG），本节将本地apt 和 pip仓库称为apt 和 pip目录。然后，\tool{}会将这两个 R-PDG 合并为一个 S-PDG，并检测 CC 问题。S-PDG 的构建分为以下三个步骤：
\begin{itemize}
	\item \textbf{步骤 1：收集 apt 和 pip 目录中的软件包。}对于 apt 目录，Hera 使用 dpkg [3] 工具（一个适用于基于 Debian 系统的底层包管理工具）根据软件包安装记录收集 apt 目录中的所有软件包。pip 提供了类似的功能，但它只能从所有系统级目录中收集软件包，无法指定只从 pip 目录中收集软件包。为了解决这个问题，\tool{} 使用 \textit{pkg\_resources} 模块根据目录路径从 pip 目录中收集所有软件包。
	\item \textbf{步骤 2：分析依赖关系并构建 R-PDG。}在该步骤中，\tool{} 分析了 apt 和 pip 目录内部的依赖关系，并构建了两个仓库级软件包依赖图（R-PDG）。R-PDG 是一个有向无环图，其中节点表示软件包，边表示目录内软件包之间的内部依赖关系，本文将其视为兼容的依赖关系。对于 apt 目录，我们基于第 \ref{4.1.2} 节中获得的 apt 仓库内部依赖关系构建 R-PDG。对于 pip 目录，我们使用依赖分析工具 pipdeptree [17] 来分析 pip 目录内部的依赖关系，并构建 R-PDG。
	\item \textbf{步骤 3：合并 R-PDG 以构建 S-PDG。}\tool{}通过合并两个 R-PDG 构建了系统级软件包依赖图（S-PDG）。图 \ref{fig:PDG} 展示了合并两个 R-PDG 以构建一个 S-PDG 的示意图，其中软件包 B 和 D 在 apt 和 pip 目录中各有一个版本。当一个软件包在两个 R-PDG 中各有一个版本时，\tool{} 会添加一条边连接这两个版本，表示 apt 中的版本被 pip 中的版本覆盖。该边从 apt R-PDG 中的节点指向 pip R-PDG 中的节点，称为覆盖边（covered-edge）。根据 Python 解释器的导入规则，被覆盖的版本将不再被使用。
	\begin{figure}[htbp] % use float package if you want it here
		\centering
		\includegraphics[width=5in]{chain}
		\caption{合并两个 R-PDG 构建S-PDG示意图}
		\label{fig:PDG}
	\end{figure}
	
\end{itemize}
\subsection{检测CC问题}\label{4.2.2}
构建 S-PDG 后，我们可以在用户的系统环境中检测 CC 问题。为了实现这一点，Hera 会查询兼容性表，以确定每条覆盖边连接的两个版本之间是否存在破坏性 API（例如，图 \ref{fig:PDG} 中软件包 B 和 D 的两个版本之间）。如果存在，说明用户系统中包含不兼容的库软件包版本，可能导致潜在的 CC 问题为了确认潜在问题，\tool{} 会查询依赖表，检查 apt 目录中的应用软件包是否使用了该破坏性 API（例如，检查图 \ref{fig:PDG}中的软件包 A 和 C）。如果存在，\tool{} 将报告一个 CC 问题。

\subsection{预测CC问题}\label{4.2.3}
在预测阶段，\tool{} 通过模拟运行安装命令，并将要安装的软件包临时添加到 S-PDG 中。具体而言，对于每个 apt 或 pip 的安装命令，\tool{} 使用 “apt install -s” 或 “pip install --dry-run” 命令来预览将要安装的软件包。随后，\tool{} 将这些软件包临时添加到 S-PDG 中，并检查是否需要添加新的覆盖边。如果需要添加新的覆盖边，\tool{} 会查询兼容性表和依赖表，检测是否会引发新的 CC 问题。如果会引发 CC 问题，\tool{} 会警告用户执行该安装命令会导致 CC 问题，并报告预测的 CC 问题的详细信息，如覆盖边两端的相关软件包。该预测机制能够有效防止在安装过程中引入 CC 问题。

\subsection{修复CC问题}\label{4.2.4}
当检测到 CC 问题时，由于 R-PDG 中包含兼容的依赖关系，\tool{} 可以据此提供修复建议。
通常有两种方法可以解决 CC 问题：a) 通过删除并重新安装软件包来断开 S-PDG 中的覆盖边，b) 指定从 apt 目录中导入兼容的库软件包。由于方案 a 可能会导致其他系统级依赖问题，因此我们推荐使用方案 b 来修复 CC 问题。基于 apt 目录的 R-PDG，\tool{} 会建议用户在导入应用软件包之前，使用 \textit{importlib} 模块从 apt 目录导入兼容的库软件包。

\section{本章小结}
本章摄入探讨了 \tool{}的设计与实现，这是一个旨在预测、检测和修复CC问题的自动化工具。 \tool{}主要包括离线和在线两个阶段，离线阶段构建一个兼容性数据库，在线阶段构建一个系统级软件包依赖图，用于检测和预测CC问题，并提供修复建议。\tool{} 能够有效地解决由不同包管理工具安装的第三方包之间发生的兼容性问题。此外，\tool{}提供了一套基于规则的方法来分析库软件包不同版本间的破坏性API更改，本方法结合静态分析和动态分析，能够更有效的识别破坏性API。

总之，本章通过设计和实现\tool{}工具，为解决跨软件生态的兼容性问题提供了思路和解决方案。展望未来，\tool{}工具有望以系统服务的形式集成到操作系统中，进一步推动系统依赖治理技术的发展，特别是在不同软件生态间的第三方包依赖方面。在后续的方面，本文将进一步探讨\tool{}的局限性和可推广性并进行全面的评估。