\chapter{相关理论基础}
在本章中，将介绍本研究的相关理论基础，主要从第三方包依赖管理和API不兼容更改两方面展开介绍。在第三方包依赖管理方面，本章将介绍各种包管理器的依赖解析策略并对于各个包管理器的优势和使用场景进行分析。在API不兼容更改方面，本章将分析API不兼容更改导致的第三方包兼容性问题，并介绍相应的检测技术。

\section{第三方包依赖管理}
\subsection{依赖解析}\label{2.1.1}
在软件生态中使用某个第三方包时，项目需要指定所需包的版本约束条件。找出满足指定版本约束条件的每个所需包的适当版本的过程称为“依赖解析”。根据版本约束的解决方式，本研究将现有的包管理器分为三类。

第一类采用迭代方式来计算可行解。具体而言，每次它首先搜索并下载一个满足版本约束条件的目标包$P_{i}$的版本，然后迭代地验$P_{i}$的每个直接依赖包的版本约束是否得到满足。Pip、poetry\upcite{Poetry} 和 pipenv 是这一类别的代表性工具。

第二类将所需包的版本约束编码为一个 SAT 求解问题，然后借助求解器直接计算每个所需包的适当版本。本质上，如果存在满足所有所需包版本约束的可行解，这种技术方案不会导致因依赖冲突而引发的构建失败。这一类别的代表性工具是 Conda\upcite{Conda}。然而，由于将依赖解析编码为 SAT 问题的复杂性，Conda 长期以来一直受到性能问题的困扰，这在其问题报告系统中已被广泛讨论\upcite{Issue7239,Issue8197,Issue8810,Issue9983,Issue11414}。此外，Conda 开发者也承认，Conda 在依赖解析方面通常比 pip 慢\upcite{Issue7239}。

第三类是固定版本策略。在以Linux发行版为代表的操作系统生态中，为了维持系统的安全性和稳定性，往往会在系统发布时维护一个版本固定的第三方包列表，每个第三方包有且只有一个版本并且各个包之间相互兼容。在此基础上，这类生态的包管理器只需检索列表安装固定版本的第三方包及其依赖包，即可避免依赖冲突问题，Ubuntu系统上的apt是此类工具的代表。

\subsection{包管理工具分析}
本研究以Python语言和Ubuntu系统两个影响广泛的软件生态为代表，研究Ubuntu系统上不同仓库中Python第三方包出现的CC问题，其中不同仓库指的是Ubuntu系统的apt包管理工具维护的第三方包仓库（本文中简称apt仓库）以及Python语言的pip包管理工具维护的的第三方包仓库（本文中简称pip仓库）。在本节中将分析这两种包管理工具安装Python包的各自优势以及用户的使用现状。

在Ubuntu系统中，Python软件包管理是系统软件依赖管理中的关键组成部分。Ubuntu以其强大的包管理工具apt而闻名它为系统提供了方便的软件安装、升级和卸载功能。同时，Python生态也有其专用的包管理工具pip，负责下载、安装和管理Python相关的软件包。在Ubuntu系统上，apt为Python软件包提供了全局的系统级别管理。这意味着通过apt安装的软件包将被整合到系统的共享库和依赖项中，为所有用户和应用程序提供一致的运行环境。使用apt管理python依赖有以下优势：
\begin{itemize}
	\item \textbf{系统级别的依赖。}Uubuntu 系统中的一些应用程序和工具依赖于特定的 Python 包（例如：Fail2ban）。Apt 能够管理这些系统级别的依赖，确保在安装、更新或卸载这些应用程序时，相关的 Python 包也会被正确处理并且可以确保系统级别的依赖关系得到正确处理。
	\item \textbf{安全性和稳定性。}Apt提供的python包都是经过严格审核测试的，可以确保这些包的安全性，而pip安装的包有可能有安全性问题。与此同时，如章节\ref{2.1.1}所说，apt仓库中的Python包通常与Ubuntu 系统版本相匹配，这有助于确保系统的稳定性。
	\item \textbf{处理非Python依赖关系。}当一个 Python 包依赖于其他非 Python 的系统库时，使用 apt 可以更好地管理这些依赖关系。Apt 包管理器会确保所有必要的依赖项被正确安装和管理。例如，LXML 是一个 Python 库，它依赖于 libxml2 和 libxslt 等 C 库。通过使用 Apt 安装 python3-lxml，可以确保这些库也被正确安装。
\end{itemize}

然而，apt只能下载数千个流行python包，当开发者需要安装其他python包时，则需要使用其他方式。Pip是开发者最流行使用的python包管理工具，可以从Python包索引（PYPI）中下载数百万python第三方包，给用户提供了极大的灵活性。Pip支持安装包及其依赖关系、版本控制和包的升级。它允许用户从一个命令行界面轻松地管理包，使得Python开发和部署更为简便。Pip 还支持从本地文件、版本控制或直接从 URL 安装包，提供了高度的灵活性和控制，是 Python社区中不可或缺的工具之一。

除了上述包管理工具之外，目前的Python项目环境配置中还有一种常见的方式是构建虚拟环境。Python虚拟环境是一种独立的目录树，包含了一个Python解释器以及一系列附加的包。使用虚拟环境可以在不影响全局Python安装的情况下，为不同项目安装不同版本的库。这种隔离的环境使得项目依赖更加清晰，避免了不同项目间依赖包版本冲突的问题。Python可以通过venv模块或者Conda工具创建、管理虚拟环境，使用简单的命令就可以激活或停用特定的虚拟环境。这样，开发者可以在各自独立的环境中开发和测试应用，确保项目的稳定性和可复现性。然而在一些情况下用户应该使用apt安装Python包而不是构建虚拟环境：
\begin{itemize}
	\item \textbf{操作系统工具和服务。}许多Ubuntu会使用 Python 编写的系统工具和服务。在这种情况下，这些工具和服务的依赖关系需要在系统级别进行管理，因此使用 apt 安装相关的 Python 包是更好的选择。例如，Ubuntu 的系统更新管理器 update-manager 依赖于 Python，这时候使用 apt 来安装和管理这些依赖关系是合适的。
	\item \textbf{需要特定包版本的应用。}当一个应用程序依赖于特定版本的系统包时（例如，需要与系统的其他组件共享包），使用 apt 可以确保包文件和应用程序之间的兼容性。例如，如果正在使用一个需要特定版本的 GTK+ 库的 Python 图形界面应用程序，那么使用 apt 安装 Python 的 GTK+ 绑定（如 python3-gi）可能是更好的选择。
\end{itemize}

综上所述，在Ubuntu系统中，用户同时使用apt和pip在系统环境中管理Python第三方包是一种正常而必要的实践，这种方式可以充分利用两者的优势，确保系统稳定性和灵活性的平衡。但由于二者的设计目标是处理生态软件库内的依赖关系，而不考虑库间的依赖关系，给CC问题的发生提供了条件。

\section{API不兼容更改}
在本文中，API（应用程序编程接口）指的是第三方包对外提供和暴露的调用接口，在Python第三方包中，包括类、函数和属性等。APT不兼容更改指第三方包在演化过程中引入的不兼容的改变（例如改变函数接口签名）。其他第三方包（应用包）使用包含不兼容接口的第三方包版本（库包）会导致发生错误，本文称之为兼容性问题。

\subsection{API不兼容更改分析}
第三方包兼容性问题通常涉及三方参与者：库包开发者、应用包开发者和终端用户。在本文中应用包和库包是一对相对概念，一个应用包可能是另一个应用包的库包。
\begin{figure}[t] % use float package if you want it here
	\centering
	\includegraphics[width=6in]{API不兼容}
	\caption{API不兼容更改导致第三方包发生兼容性问题}
	\label{fig:API}
\end{figure}
图\ref{fig:API}展示了API不兼容更改导致第三方包发生兼容性问题的两个场景。首先，库包开发人员发布两个包含不兼容更改的版本，不兼容更改分为两种情况：前向不兼容更改（如增加一个函数接口）和后向不兼容更改（如删除一个函数接口）。图中实线表示后向不兼容更改产生包兼容性问题的过程：即应用包开发者基于旧的库包开发，终端用户在运行时将应用包链接到新的库包版本。类似地，图中的短横线表示前向不兼容更改产生包兼容性问题的过程：即应用包开发者基于新的库包版本开发软件，终端用户在运行时将应用包链接到旧的库包版本。

当第三方包发生不兼容更改时，上述三方参与者可以采用不同的方法避免第三方包第三方包兼容性问题：1）库包开发者在最新的库包版本中撤销不兼容更改；2）应用包开发者升级应用包以适应库包的变化；3）终端用户避免使用不兼容的库包版本。有很多研究工作关注检测第三方包的变化\upcite{brito2018apidiff,foo2018efficient,meng2012history,mezzetti2018type,ponomarenko2012backward,wu2010aura}，并报告给库包开发者（使用第一种方法解决）。还有一些研究工作关注检测软件对不兼容API 的使用\upcite{he2018understanding,jezek2013software,li2018cid,wang2019could}，或帮助软件适应库包的变化\upcite{balaban2005refactoring,henkel2005catchup,perkins2005automatically,xing2007api}。这些技术可以帮助应用包开发人员更新应用包（使用第二种方法
解决）。但上述两种情况下，终端用户均已经遭受第三方包兼容性问题，并需要等待库包
或应用包发布新的版本。相比之下，第三种方法更为轻量级：终端用户从一开始就
避免使用不兼容库包版本，从而避免兼容性问题。在本研究中，本文基于这三种解决方案的相关研究工作，通过检测库包间的不兼容API和应用包对于库包不兼容API的使用，构建兼容性数据库进而支持终端用户避免使用不兼容的库包版本。

\subsection{API不兼容更改检测}
API不兼容更改检测是一个关键的第三方包维护活动，旨在识别和评估由于API更新而可能导致的兼容性问题。这种检测通常涉及到分析API的历史版本与新版本之间的差异，以确定哪些更改可能会破坏依赖于这些API的现有应用包。有效的API不兼容更改检测可以帮助终端用户避免潜在的第三方包兼容性问题。

API不兼容更改检测可以通过多种技术和工具来实现，主要包括静态分析和动态分析两种方法。静态分析和动态分析是根据代码是否在执行过程中进行分析来区分的。静态分析不涉及程序的运行，它通过分析代码或二进制文件来检测问题。这种方法可以覆盖代码的所有潜在执行路径，但可能会产生较多的误报。相比之下，动态分析在程序运行时进行，能够实时检测程序的行为，这使其更加有效地识别出实际运行中可能出现的漏洞。然而，它也有局限性，可能无法发现在当前测试环境下未被触发的潜在漏洞。在静态分析方面，主要有以下三种方式进行分析：
\begin{itemize}
	\item \textbf{签名比较。}通过比较API的签名（如方法名称、参数类型、返回类型等）来识别API不兼容更改。这种方法可以快速发现显著的改变，如方法的移除或参数的修改。
	\item \textbf{代码模式分析。}分析API实现的代码模式变化，如算法逻辑的变动或状态条件的修改。
	\item \textbf{依赖树分析。}分析应用包的依赖关系，确定哪些应用包代码可能受到API不兼容更改的影响。
\end{itemize}
在动态分析方面，主要有以下两种方式进行分析：
\begin{itemize}
	\item \textbf{回归测试。}运行旧版本API的测试套件对新版本进行测试，查看是否存在功能回归。
	\item \textbf{行为比较。}通过模拟或实际执行两个版本的API来比较其运行时行为的差异。
\end{itemize}

在后续的研究中，本文设计了一种自动化解决CC问题的工具\tool{}，其中关键的一部分是构建跨软件生态的兼容性数据库，数据库中包含两个表格，分别为（1）依赖表：对于apt仓库中的每个应用包，该表收集其对apt仓库中各个库包的API使用情况和（2）兼容性表：对于apt仓库中的每个库包，该表收集其与pip仓库中不同版本的同名库包的API兼容性。\tool{}基于静态分析技术，实现分析应用包中对库包API的使用。\tool{}结合静态分析和动态分析技术，实现分析apt仓库和pip仓库中不同版本的同名库包的API兼容性。

\section{程序分析}
程序分析是软件开发中用于评估和改善程序代码兼容性、性能和可靠性的关键技术。通过深入分析代码，开发者可以确保不同软件组件之间的顺利交互，并减少运行时错误。这种分析通常分为两大类：静态分析和动态分析，每种方法针对不同的分析需求提供独特的视角和技术。

\subsection{静态分析}
静态分析是在程序执行前对代码进行的分析，目的是在不运行程序的情况下发现可能的错误和兼容性问题。它依赖于对代码的深入理解和自动化检查，能够覆盖代码的所有可能执行路径。静态分析通过分析程序的源代码、字节码或二进制执行文件，预测程序在运行时可能的行为。它不涉及程序代码的实际执行，而是利用各种算法和模型来模拟程序执行的结果。静态分析主要有以下关键技术：抽象语法树，数据流分析，控制流分析和符号执行。

\textbf{抽象语法树：}抽象语法树（AST）是源代码的树状表示，用于表达程序结构的层次关系。每个节点代表程序中的一个构造，如表达式、语句或声明。静态分析工具通过遍历AST，能够详细检查代码的每个元素，评估其对整体程序行为的影响。AST是实现代码优化、复杂度分析和代码重构等功能的基础。通过精确分析AST，可以精确地识别出代码中的逻辑错误、不兼容的API调用和潜在的安全漏洞。

\textbf{数据流分析：} 数据流分析通过跟踪程序中各变量的定义和使用来识别潜在的代码缺陷，如未初始化的变量、冗余的代码或潜在的空指针引用。这项技术不仅检测错误，还能优化编译器的代码生成，提高程序的运行效率。

\textbf{控制流分析：} 控制流分析涉及构建和分析程序的控制流图（CFG）。CFG帮助分析程序的执行路径，检测死循环或不可达代码。此外，通过对CFG的详细分析，可以优化程序结构，改进代码执行路径，从而提升程序性能。

\textbf{符号执行：} 符号执行是一种强大的静态分析技术，它使用符号值而非实际数据执行程序。通过这种方式，分析者可以探索程序的所有可能执行路径，检查路径特定条件下的程序行为。这不仅能发现难以通过常规测试触发的错误，还能帮助验证程序中的安全策略和业务逻辑。

静态分析有许多应用实例，本节介绍两类代表性应用。（1）代码兼容性检查：静态分析工具如 ESLint、SonarQube 专门用于检查代码兼容性问题，确保代码遵循最新的编程标准和兼容性指南。这些工具可以集成到持续集成/持续部署（CI/CD）管道中，自动检测提交的代码是否满足预设的质量标准。（2）漏洞识别：工具如 Fortify 和 Coverity 通过静态分析识别常见的安全漏洞，例如跨站脚本（XSS）和SQL注入。这些工具使用先进的模式匹配和数据流分析技术来检测可能被攻击者利用的代码弱点。

\subsection{动态分析}
动态分析在程序运行时进行，直接分析程序的执行行为。通过监控程序执行，动态分析提供关于程序实际运行状态的直接数据，这对于性能调优、错误诊断和验证软件行为尤其重要。动态分析涉及在程序运行时收集关于其行为的信息。这种分析依赖于程序的实际执行，可以利用测试用例或在生产环境中监控程序。动态分析主要有以下关键技术：代码覆盖率分析，性能分析，异常监测和追踪和日志记录。

\textbf{代码覆盖率分析}： 通过测量在程序测试过程中实际执行的代码部分，代码覆盖率分析帮助评估测试的全面性和效果。这不仅提供了测试的定量评估，还指导开发者优化测试案例，确保重要的代码路径得到充分测试。

\textbf{性能分析：} 性能分析工具如 Profiler 分析程序的执行时间和资源消耗，识别性能瓶颈。通过详细的运行时数据，这些工具可以帮助开发者了解程序在不同条件下的表现，并指出优化的具体方向。

\textbf{异常监测：} 动态分析工具实时捕获程序运行时的异常和错误，提供关键的故障诊断信息。这些工具通常能够追踪到异常发生的具体位置和条件，大大缩短了问题定位和修复的时间。

\textbf{追踪和日志记录：} 追踪程序的执行轨迹，记录详细的运行时数据，帮助开发者了解程序行为和出现问题的环节。这些数据对于后续的程序优化和错误预防具有重要价值。

静态分析也有许多应用实例，本节介绍两类代表性应用。（1）性能优化：动态分析工具如 New Relic 和 Dynatrace 在生产环境中监控应用程序的性能，提供实时性能优化建议。这些工具的洞察帮助开发团队快速响应性能问题，保证应用程序的高效运行。
（2）实时错误跟踪：工具如 Sentry 和 Bugsnag 在应用程序运行时监控错误，提供即时反馈和修复支持。这些工具的实时错误跟踪功能对于维护复杂的生产环境非常关键，帮助团队减少应用宕机时间和提高用户满意度。

结合静态和动态分析为代码兼容性提供了全面的保障。静态分析提前发现潜在错误和兼容性问题，而动态分析补充实际运行时的观察，两者相结合，使开发者能够更全面地理解和优化软件。这种综合方法不仅提升了软件的质量和性能，也增强了代码的兼容性和可维护性，是现代软件开发不可或缺的一部分。
\section{本章小结}
本章深入而系统地探讨了跨软件生态的兼容性问题的相关理论基础，涵盖了第三方包依赖管理和API不兼容更改等多个关键领域。首先，本章分析了不同包管理工具的依赖解析策略，并探讨了它们的优势和适用场景，尤其是在Python语言和Ubuntu系统中广泛使用的apt和pip。此外，本章探讨了API不兼容更改对第三方包兼容性的影响，以及如何通过静态分析和动态分析技术来检测这些更改。最后，本章从静态分析和动态分析两方面介绍了程序分析技术，重点介绍了关键技术原理和应用实例。这些相关理论基础为后续章节中提出的实证研究和解决方案提供了重要的理论背景和技术基础，也为后续的实验设计奠定了基石。
\ignore{
\label{sec:font}

陈赓（1903年2月27日－1961年3月16日），原名陈庶康，中国湖南湘乡人，军事家。出生将门，其祖父为湘军将领陈翼怀。

Adobe中文字体有四种：

{\kai 楷体\verb|\kai|：陈赓，中国湖南湘乡人，军事家。出生将门，其祖父为湘军将领陈翼怀。%
1952年筹办并任人民解放军军事工程学院第一任院长兼政委，培养国防科技人才。1955年被授予大将军衔。}

{\fs 仿宋\verb|\fs|：陈赓，中国湖南湘乡人，军事家。出生将门，其祖父为湘军将领陈翼怀。%
1952年筹办并任人民解放军军事工程学院第一任院长兼政委，培养国防科技人才。1955年被授予大将军衔。}

{\hei 黑体\verb|\hei|：陈赓，中国湖南湘乡人，军事家。出生将门，其祖父为湘军将领陈翼怀。%
1952年筹办并任人民解放军军事工程学院第一任院长兼政委，培养国防科技人才。1955年被授予大将军衔。}

宋体就是正文字体了。下面测试字体大小，\LaTeX{}默认的列表环境会在
条目之间插入过多的行距，在下面这种情况可能正好，若用户需要
{\kai 正文行距}的列表环境，可以使用compactitem环境，记住这点很重要，不要再
用那种自己修改\verb|itemsep|的傻傻的办法了。
\begin{itemize}
\item[初号] {\song\chuhao 陈赓大将}
\item[小初] {\song\xiaochu 陈赓大将}
\item[一号] {\song\yihao 陈赓大将}
\item[小一] {\song\xiaoyi 陈赓大将}
\item[二号] {\song\erhao 陈赓大将}
\item[小二] {\song\xiaoer 陈赓大将}
\item[三号] {\song\sanhao 陈赓大将}
\item[小三] {\song\xiaosan 陈赓大将}
\item[四号] {\song\sihao 陈赓大将}
\item[小四] {\song\xiaosi 陈赓大将}
\item[五号] {\song\wuhao 陈赓大将}
\item[小五] {\song\xiaowu 陈赓大将}
\end{itemize}

\section{表格明细}
\label{sec:figure}
表格是论文的重要组成部分，我们从简单的表格讲起，到复杂的表格为止。

模板中关于表格的宏包有三个： \textsf{booktabs}、\textsf{array} 和
\textsf{longtabular}。三线表建议使用\textsf{booktabs}中提供的，
包含toprule、midrule 和 bottomrule三条命令，简单干脆！
它们与\textsf{longtable} 能很好的配合使用。下面来看一个表格实例：
\begin{table}[htb]
  \centering
  \begin{minipage}[t]{0.8\linewidth} % 如果想在表格中使用脚注，minipage是个不错的办法
  \caption[模板文件]{模板文件。如果表格的标题很长，那么在表格索引中就会很不美
    观，所以要像 chapter 那样在前面用中括号写一个简短的标题。这个标题会出现在索
    引中。}
  \label{tab:template-files}
    \begin{tabular*}{\linewidth}{lp{10cm}}
      \toprule[1.5pt]
      {\hei 文件名} & {\hei 描述} \\
      \midrule[1pt]
      nudtpaper.ins & \LaTeX{} 安装文件，docstrip\footnote{表格中的脚注} \\
      nudtpaper.dtx & 所有的一切都在这里面\footnote{再来一个}。\\
      nudtpaper.cls & 模板类文件。\\
      nudtpaper.cfg & 模板配置文。cls 和 cfg 由前两个文件生成。\\
      bstutf8.bst   & 参考文献 Bibtex 样式文件。\\
      mynudt.sty    & 常用的包和命令写在这里，减轻主文件的负担。\\
      \bottomrule[1.5pt]
    \end{tabular*}
  \end{minipage}
\end{table}

表 \ref{tab:template-files} 列举了本模板主要文件及其功能，基本上来说论文
中最可能用到的就是这种表格形式了。
请大家注意三线表中各条线对应的命令。这个例子还展示了如何在表格中正确使用脚注。
如果你不需要在表格中插入脚注，可以将minipage环境去掉。
由于\LaTeX{}本身不支持在表格中使用\verb|\footnote|，所以我们不得不将表格放在
小页中，而且最好将表格的宽度设置为小页的宽度，这样脚注看起来才更美观。

另外六院的同学在使用模板时需要使用一种固定宽度（往往是页宽，下面的例子由
rongdonghu提供）的表格，内容需要居中且可以自动调整。
解决办法是自定义了一种\verb|tabularx|中的\textbf{Z}环境，在论文模板中，
该命令已添加到\verb|mynudt.sty|中。下面是这种情况的实例：

\begin{table}[htbp]
\centering
\begin{minipage}[t]{0.9\linewidth}
\caption{Reed Solomon码的典型应用}
\label{tab:RSuse}
\begin{tabularx}{\linewidth}{cZ}
\toprule[1.5pt]
{\hei 应用领域} & {\hei 编码方案}\\
\midrule[1pt]
磁盘驱动器 & RS(32,28,5)码 \footnote{码长为32、维数为28、最小距离为5} \\
CD & 交叉交织RS码(CIRC) \\
DVD & RS(208,192,17)码、RS(182,172,11)码 \\
光纤通信 & RS(255,229,17)码 \\
\bottomrule[1.5pt]
\end{tabularx}
\end{minipage}
\end{table}

我们经常会在表格下方标注数据来源，或者对表格里面的条目进行解释。前面的脚注是一种
不错的方法，如果你不喜欢minipage方法的脚注。
那么完全可以在表格后面自己写注释，比如表~\ref{tab:tabexamp1}。
\begin{table}[htbp]
  \centering
  \caption{复杂表格示例 1}
  \label{tab:tabexamp1}
  \begin{minipage}[t]{0.8\textwidth} 
    \begin{tabularx}{\linewidth}{|l|X|X|X|X|}
      \hline
      \multirow{2}*{\backslashbox{x}{y}}  & \multicolumn{2}{c|}{First Half} & \multicolumn{2}{c|}{Second Half}\\
      \cline{2-5}
      & 1st Qtr &2nd Qtr&3rd Qtr&4th Qtr \\ 
      \hline
      \multirow{2}*{East$^{*}$} &   20.4&   27.4&   90&     20.4 \\
       &   30.6 &   38.6 &   34.6 &  31.6 \\ 
      West$^{**}$ &   30.6 &   38.6 &   34.6 &  31.6 \\ 
      \hline
    \end{tabularx}\\[2pt]
    \footnotesize
    *：东部\\
    **：西部
  \end{minipage}
\end{table}

此外，表~\ref{tab:tabexamp1} 同时还演示了另外三个功能：1）通过 \textsf{tabularx} 的
 \texttt{|X|} 扩展实现表格内容自动调整；2）通过命令 \verb|\backslashbox| 在表头部分
插入反斜线（WORD中很简单，但\LaTeX{}做表格需要一定的（极大的）想象力）；3）就是
使用\verb|multirow|和\verb|multicolumn|命令。

不可否认 \LaTeX{} 的表格功能没有想象中的那么强大，不过只要你足够认真，足够细致，那么
同样可以排出来非常复杂非常漂亮的表格。可是科技论文中那么复杂表格有什么用呢？
上面那个表格就够用啦。

浮动体的并排放置一般有两种情况：1）二者没有关系，为两个独立的浮动体；2）二者隶属
于同一个浮动体。对表格来说并排表格既可以像表~\ref{tab:parallel1}、表~\ref{tab:parallel2} 
使用小页环境，也可以如表~\ref{tab:subtable}使用子表格来做。
图与表同出一源，后面我们将讲解子图(subfloat)的例子。
\begin{table}[htb]
\centering
\noindent\begin{minipage}{0.45\textwidth}
\centering
\caption{第一个并排子表格}
\label{tab:parallel1}
\begin{tabular}{p{2cm}p{2cm}}
\toprule[1.5pt]
111 & 222 \\\midrule[1pt]
222 & 333 \\\bottomrule[1.5pt]
\end{tabular}
\end{minipage}
\begin{minipage}{0.45\textwidth}
\centering
\caption{第二个并排子表格}
\label{tab:parallel2}
\begin{tabular}{p{2cm}p{2cm}}
\toprule[1.5pt]
111 & 222 \\\midrule[1pt]
222 & 333 \\\bottomrule[1.5pt]
\end{tabular}
\end{minipage}
\end{table}
\begin{table}[htbp]
\centering
\caption{并排子表格}
\label{tab:subtable}
\subfloat[第一个子表格]{
\begin{tabular}{p{2cm}p{2cm}}
\toprule[1.5pt]
111 & 222 \\\midrule[1pt]
222 & 333 \\\bottomrule[1.5pt]
\end{tabular}}\hskip2cm
\subfloat[第二个子表格]{
\begin{tabular}{p{2cm}p{2cm}}
\toprule[1.5pt]
111 & 222 \\\midrule[1pt]
222 & 333 \\\bottomrule[1.5pt]
\end{tabular}}
\end{table}

如果您要排版的表格长度超过一页，那么推荐使用\textsf{longtable}命令。
这里随便敲入一些无关的文字，使得正文看上去不是那么的少。
表~\ref{tab:performance} 就是 \textsf{longtable} 的简单示例。
\begin{longtable}[c]{c*{6}{r}}
\caption{实验数据}\label{tab:performance}\\
\toprule[1.5pt]
 测试程序 & \multicolumn{1}{c}{正常运行} & \multicolumn{1}{c}{同步}
& \multicolumn{1}{c}{检查点}   & \multicolumn{1}{c}{卷回恢复}
& \multicolumn{1}{c}{进程迁移} & \multicolumn{1}{c}{检查点} 	\\
& \multicolumn{1}{c}{时间 (s)} & \multicolumn{1}{c}{时间 (s)}
& \multicolumn{1}{c}{时间 (s)} & \multicolumn{1}{c}{时间 (s)}
& \multicolumn{1}{c}{时间 (s)} &  文件（KB）			\\
\midrule[1pt]%
\endfirsthead%

\multicolumn{7}{c}{续表~\thetable\hskip1em 实验数据}\\

\toprule[1.5pt]
 测试程序 & \multicolumn{1}{c}{正常运行} & \multicolumn{1}{c}{同步} 
& \multicolumn{1}{c}{检查点}   & \multicolumn{1}{c}{卷回恢复}
& \multicolumn{1}{c}{进程迁移} & \multicolumn{1}{c}{检查点} 	\\
& \multicolumn{1}{c}{时间 (s)} & \multicolumn{1}{c}{时间 (s)}
& \multicolumn{1}{c}{时间 (s)} & \multicolumn{1}{c}{时间 (s)}
& \multicolumn{1}{c}{时间 (s)} &  文件（KB）			\\
\midrule[1pt]%
\endhead%
\hline%

\multicolumn{7}{r}{续下页}%

\endfoot%
\endlastfoot%
CG.A.2 & 23.05   & 0.002 & 0.116 & 0.035 & 0.589 & 32491  \\
CG.A.4 & 15.06   & 0.003 & 0.067 & 0.021 & 0.351 & 18211  \\
CG.A.8 & 13.38   & 0.004 & 0.072 & 0.023 & 0.210 & 9890   \\
CG.B.2 & 867.45  & 0.002 & 0.864 & 0.232 & 3.256 & 228562 \\
CG.B.4 & 501.61  & 0.003 & 0.438 & 0.136 & 2.075 & 123862 \\
CG.B.8 & 384.65  & 0.004 & 0.457 & 0.108 & 1.235 & 63777  \\
MG.A.2 & 112.27  & 0.002 & 0.846 & 0.237 & 3.930 & 236473 \\
MG.A.4 & 59.84   & 0.003 & 0.442 & 0.128 & 2.070 & 123875 \\
MG.A.8 & 31.38   & 0.003 & 0.476 & 0.114 & 1.041 & 60627  \\
MG.B.2 & 526.28  & 0.002 & 0.821 & 0.238 & 4.176 & 236635 \\
MG.B.4 & 280.11  & 0.003 & 0.432 & 0.130 & 1.706 & 123793 \\
MG.B.8 & 148.29  & 0.003 & 0.442 & 0.116 & 0.893 & 60600  \\
LU.A.2 & 2116.54 & 0.002 & 0.110 & 0.030 & 0.532 & 28754  \\
LU.A.4 & 1102.50 & 0.002 & 0.069 & 0.017 & 0.255 & 14915  \\
LU.A.8 & 574.47  & 0.003 & 0.067 & 0.016 & 0.192 & 8655   \\
LU.B.2 & 9712.87 & 0.002 & 0.357 & 0.104 & 1.734 & 101975 \\
LU.B.4 & 4757.80 & 0.003 & 0.190 & 0.056 & 0.808 & 53522  \\
LU.B.8 & 2444.05 & 0.004 & 0.222 & 0.057 & 0.548 & 30134  \\
EP.A.2 & 123.81  & 0.002 & 0.010 & 0.003 & 0.074 & 1834   \\
EP.A.4 & 61.92   & 0.003 & 0.011 & 0.004 & 0.073 & 1743   \\
EP.A.8 & 31.06   & 0.004 & 0.017 & 0.005 & 0.073 & 1661   \\
EP.B.2 & 495.49  & 0.001 & 0.009 & 0.003 & 0.196 & 2011   \\
EP.B.4 & 247.69  & 0.002 & 0.012 & 0.004 & 0.122 & 1663   \\
EP.B.8 & 126.74  & 0.003 & 0.017 & 0.005 & 0.083 & 1656   \\
\bottomrule[1.5pt]
\end{longtable}

另外，有的同学不想让某个表格或者图片出现在索引里面，那么请使用命令 \verb|\caption*{}|，
这个命令不会给表格编号，也就是出来的只有标题文字而没有“表~XX”，“图~XX”，否则
索引里面序号{\kai 不连续}就显得不伦不类，这也是 \LaTeX{} 里星号命令默认的规则。

\section{绘图插图}

本模板不再预先装载任何绘图包（如 \textsf{pstricks，pgf} 等），完全由你自己来决定。
个人觉得 \textsf{pgf} 不错，不依赖于 Postscript。此外还有很多针对 \LaTeX{} 的
 GUI 作图工具，如 XFig(jFig), WinFig, Tpx, Ipe, Dia, Inkscape, LaTeXPiX,
jPicEdt 等等。本人强烈推荐\textsf{Ipe}。

一般图形都是处在浮动环境中。之所以称为浮动是指最终排版效果图形的位置不一定与源文
件中的位置对应，这也是刚使用 \LaTeX{} 同学可能遇到的问题。
如果要强制固定浮动图形的位置，请使用 \textsf{float} 宏包，
它提供了 \texttt{[H]}（意思是图片就给我放在这里\textcolor{red}{H}ere）参数，
但是除非特别需要，不建议使用\texttt{[H]}，而是推荐使用\texttt{[htbp]}，
给\LaTeX{}更多选择。比如图~\ref{fig:ipe}。
\begin{figure}[htbp] % use float package if you want it here
  \centering
  \includegraphics[width=3in]{hello}
  \caption{利用IPE制图}
  \label{fig:ipe}
\end{figure}

若子图共用一个计数器，
那么请看图~\ref{fig:big1}，它包含两个小图，分别是图~\ref{fig:subfig1} 
和图~\ref{fig:subfig2}。这里推荐使用\verb|\subfloat|，{\bf 不要再用}
\verb|\subfigure|和\verb|\subtable|。
\begin{figure}[htb]
  \centering%
  \subfloat[第一个小图形]{%
    \label{fig:subfig1}
    \includegraphics[height=2cm]{xh}}\hspace{4em}%
  \subfloat[第二个小图形。如果标题很长的话，它会自动换行，这个 caption 就是这样的例子]{%
    \label{fig:subfig2}
    \includegraphics[height=2cm]{xhh}}
  \caption{包含子图形的大图形}
  \label{fig:big1}
\end{figure}

而下面这个例子显示并排$3\times2$的图片，见图\ref{fig:subfig:3x2}:
\begin{figure}[htb]
\centering
\subfloat[]{\includegraphics[width=.27\textwidth]{typography}} \qquad
\subfloat[]{\includegraphics[width=.27\textwidth]{typography}} \qquad
\subfloat[]{\includegraphics[width=.27\textwidth]{typography}} \qquad
\subfloat[]{\includegraphics[width=.27\textwidth]{typography}} \qquad
\subfloat[]{\includegraphics[width=.27\textwidth]{typography}} \qquad
\subfloat[]{\includegraphics[width=.27\textwidth]{typography}}
\caption{并排图片}
\label{fig:subfig:3x2}
\end{figure}

要注意，图\ref{fig:subfig:3x2}例中
\texttt{qquad}相当于\verb|\hspace{2em}|，也就是2个字符的宽度，约0.08倍页宽，
图片宽度设定为0.27倍页宽是合适的；在该环境中，尽量不要手动换行，所以，不妨自己计算一下！

如果要把编号的两个图形并排，那么小页(minipage)就非常有用了，可以分别参考
图\ref{fig:parallel1}和图\ref{fig:parallel2}。其实这个例子和表格一节中并排
放置的表格一摸一样。
\begin{figure}[htb]
\begin{minipage}{0.48\textwidth}
  \centering
  \includegraphics[height=1.2cm]{xhh}
  \caption{并排第一个图}
  \label{fig:parallel1}
\end{minipage}\hfill
\begin{minipage}{0.48\textwidth}
  \centering
  \includegraphics[height=1.2cm]{xhh}
  \caption{并排第二个图}
  \label{fig:parallel2}
\end{minipage}
\end{figure}

图形就说这么多，因为大家在写论文是遇到的最大问题不是怎么把图插进去，
而是怎样做出专业的、诡异的、震撼的图片来，记得在这时参考前面推荐的那
些工具吧，当然必不可少的是Matlab了，至于如何加入中文标注、支持中文等等
可以上网去查，但这里{\kai 推荐一点}，用好export命令，使得插入图片时尽可能的不要
缩放，保证图文的一致性。

\section{公式定理}
\label{sec:equation}
贝叶斯公式如式~(\ref{equ:chap1:bayes})，其中$p(y|\mathbf{x})$为后验；
$p(\mathbf{x})$为先验；分母$p(\mathbf{x})$ 为归一化因子，这是
实际应用中十分恐怖的一个积分式。
\begin{equation}
\label{equ:chap1:bayes}
p(y|\mathbf{x}) = \frac{p(\mathbf{x},y)}{p(\mathbf{x})}=
\frac{p(\mathbf{x}|y)p(y)}{p(\mathbf{x})} 
\end{equation}

论文里面公式越多，\TeX{} 就越 happy。再看一个 \textsf{amsmath} 的例子：
\newcommand{\envert}[1]{\left\lvert#1\right\rvert} 
\begin{equation}\label{detK2}
\det\mathbf{K}(t=1,t_1,\dots,t_n)=\sum_{I\in\mathbf{n}}(-1)^{\envert{I}}
\prod_{i\in I}t_i\prod_{j\in I}(D_j+\lambda_jt_j)\det\mathbf{A}
^{(\lambda)}(\overline{I}|\overline{I})=0.
\end{equation} 

大家在写公式的时候一定要好好看\textsf{amsmath}的文档，并参考模板中的用法：
\begin{multline*}%\tag{[b]} % 这个出现在索引中的
\int_a^b\biggl\{\int_a^b[f(x)^2g(y)^2+f(y)^2g(x)^2]
 -2f(x)g(x)f(y)g(y)\,dx\biggr\}\,dy \\
 =\int_a^b\biggl\{g(y)^2\int_a^bf^2+f(y)^2
  \int_a^b g^2-2f(y)g(y)\int_a^b fg\biggr\}\,dy
\end{multline*}

再看\ref{equ:split}:
\begin{equation}\label{equ:split}
\begin{split}
C(z) &= [z^n] \biggl[\frac{e^{3/4}}{\sqrt{1-z}} +
e^{-3/4}(1-z)^{1/2} + \frac{e^{-3/4}}{4}(1-z)^{3/2}
+ O\Bigl( (1-z)^{5/2}\Bigr)\biggr] \\
&= \frac{e^{-3/4}}{\sqrt{\pi n}} - \frac{5e^{-3/4}}{8\sqrt{\pi
n^3}} + \frac{e^{-3/4}}{128 \sqrt{\pi n^5}} +
O\biggl(\frac{1}{\sqrt{\pi
n^7}}\biggr)
\end{split}
\end{equation}

当然了，数学中必不可少的是定理和证明：
\begin{theorem}
  \label{chapTSthm:rayleigh solution}
  假定 $X$ 的二阶矩存在:
  \begin{equation}
         O_R(\mathbf{x},F)=\sqrt{\frac{\mathbf{u}_1^T\mathbf{A}\mathbf{u}_1} {\mathbf{u}_1^T\mathbf{B}\mathbf{u}_1}}=\sqrt{\lambda_1},
  \end{equation}
  其中 $\mathbf{A}$ 等于 $(\mathbf{x}-EX)(\mathbf{x}-EX)^T$，$\mathbf{B}$ 表示协方差阵 $E(X-EX)(X-EX)^T$，$\lambda_1$
$\mathbf{u}_1$是$\lambda_1$对应的特征向量，
\end{theorem}

对于希腊符号使用\verb|mathbf|命令可能有些问题，所以建议对符号
用\verb|bm|加粗，记得用\verb|\up<greek>|切换正体符号，下面看几个例子：
\verb|\gamma|斜体代表变量$\gamma$，\verb|\bm{\upgamma}|正体代表向量$\bm{\upgamma}$,
。\verb|\Gamma|正体代表操作符号$\Gamma$，
\verb|\bm{\Gamma}|正体粗体代表矩阵形式$\bm{\Gamma}$，
\verb|\varGamma|斜体代表变量$\varGamma$。另外对于大小写斜体的加粗可以见$\bm{\gamma}$和$\bm{\varGamma}$，
但是这两种科技论文中很少出现，这里只做测试。
非符号普通向量就用\verb|\mathbf|吧：$\mathbf{x}_k,\mathbf{X}_k$。
完整测试如下$\omega,\bm{\omega},\upomega,\bm{\upomega},\Omega,\bm{\Omega},\varOmega,\bm{\varOmega}$。

\begin{proof}
上述优化问题显然是一个Rayleigh商问题。我们有
  \begin{align}
     O_R(\mathbf{x},F)=\sqrt{\frac{\mathbf{u}_1^T\mathbf{A}\mathbf{u}_1} {\mathbf{u}_1^T\mathbf{B}\mathbf{u}_1}}=\sqrt{\lambda_1},
 \end{align}
 其中 $\lambda_1$ 下列广义特征值问题的最大特征值：
$$
\mathbf{A}\mathbf{z}=\lambda\mathbf{B}\mathbf{z}, \mathbf{z}\neq 0.
$$
 $\mathbf{u}_1$ 是 $\lambda_1$对应的特征向量。结论成立。
\end{proof}

下面来看看算法环境的定义和使用。
我们知道，故障诊断的最终目的，是将故障定位到部件，而由于信号--部件依赖矩阵的存在，因此，实质性的工作是找出由故障部件发出异常信号，
不妨称为源异常信号，而如前所述，源异常信号与异常信号依赖矩阵$\mathbf{S_a}$的全零列是存在一一对应的关系的。因此，我们只要获得了$\mathbf{S_a}$的全零列的相关信息，
也就获得了源异常信号的信息，从而能进一步找到故障源。
通过以上分析，我们构造算法\ref{alg53}，用于实现非回路故障诊断。
\begin{algorithm}[htbp]
  \caption{非回路故障诊断算法}
  \label{alg53}
  \begin{algorithmic}[1]
    \REQUIRE 信号--部件依赖矩阵$\mathbf{A}$，信号依赖矩阵$\mathbf{S}$，信号状态向量$\alpha$
    \ENSURE 部件状态向量$\gamma$
    \STATE $\mathbf{P}\leftarrow\left(<\alpha>\right)$
    \STATE $\mathbf{S_{a}}\leftarrow\mathbf{P^T}\mathbf{S}\mathbf{P}$
    \FOR{$i=1$ to $S_a$的阶数$m$}
    \STATE $s_i\leftarrow s_i$的第$i$个行向量
    \ENDFOR
    \STATE $\beta_a\leftarrow\lnot \left(s_1\lor s_2\lor \cdots\lor s_m\right)^T$
    \STATE $\beta\leftarrow\mathbf{P}\beta_a$
    \STATE $\gamma\leftarrow\mathbf{A}\beta$
  \end{algorithmic}
\end{algorithm}

第一类故障回路推理与非回路故障推理是算法基本相同，稍微不同的是$\beta_a$的计算。因为第一类故障回路中的信号全部可能是源异常信号，因此我们不必计算
$\beta_a=\lnot \left(\left[s_1\lor s_2\lor \cdots\lor s_m\right]^T\right)$，而直接取$\beta_a=\underbrace{\left[\begin{array}{cccc}1&1&\cdots&1\end{array}\right]^T}_m$，将$\beta_a$代入
算法\ref{alg53}，有
\[\beta=\mathbf{P}\beta_a=\mathbf{P}\underbrace{\left[\begin{array}{cccc}1&1&\cdots&1\end{array}\right]^T}_m=\alpha\]
因此一类故障回路的推理算法变得相当简单，例如算法\ref{alg54}
\begin{algorithm}[htbp]
  \caption{第一类故障回路诊断算法}
  \label{alg54}
  \begin{algorithmic}[1]
    \REQUIRE 信号--部件依赖矩阵$\mathbf{A}$，信号状态向量$\alpha$
    \ENSURE 部件状态向量$\gamma$
    \STATE $\gamma\leftarrow\mathbf{A}\alpha$
  \end{algorithmic}
\end{algorithm}

\section{参考文献}
\label{sec:bib}
当然参考文献可以直接写 bibitem，虽然费点功夫，但是好控制，各种格式可以自己随意改
写，在nudtpaper里面，建议使用JabRef编辑和管理文献，再结合\verb|bstutf8.bst|，
对中文的支持非常不错，格式也很规范。

本模板推荐使用 BIB\TeX，样式文件为 bstutf8.bst，符合学校的参考文献格式（如专利
等引用未加详细测试）。看看这个例子，关于书的\upcite{tex, companion}，
还有这些\upcite{Krasnogor2004e, clzs, zjsw}，关于杂志的\upcite{ELIDRISSI94,
  MELLINGER96, SHELL02}，硕士论文\upcite{zhubajie, metamori2004}，博士论文
\upcite{shaheshang, FistSystem01}，标准文件\upcite{IEEE-1363}，会议论文\upcite{DPMG,kocher99}，%
技术报告\upcite{NPB2}。中文参考文献\upcite{cnarticle}\textsf{特别注意}，需要在\verb|bibitem|中
增加\verb|language|域并设为\verb|zh|，英文此项可不填，之后由\verb|bstutf8|统一处理
(具体就是决定一些文献在中英文不同环境下的显示格式，如等、etc)。
若使用\verb|JabRef|，则你可按下面步骤来设置：
选择\textsf{Options}$\rightarrow$\textsf{Set Up General Fields}，
在\verb|General:|后加入\verb|language|就可以了。

有时候不想要上标，那么可以这样 \cite{shaheshang}，这个非常重要。

\section{代码高亮}
有些时候我们需要在论文中引入一段代码，用来衬托正文的内容，或者体现关键思路的实现。
在模板中，统一使用\texttt{listings}宏包，并且设置了基本的内容格式，并建议用户只
使用三个接口，分别控制：编程语言，行号以及边框。简洁达意即可，下面分别举例说明。

首先是设定语言，来一个C的，使用的是默认设置：
\begin{lstlisting}[language=C]
void sort(int arr[], int beg, int end)
{
  if (end > beg + 1)
  {
    int piv = arr[beg], l = beg + 1, r = end;
    while (l < r)
    {
      if (arr[l] <= piv)
        l++;
      else
        swap(&arr[l], &arr[--r]);
    }
    swap(&arr[--l], &arr[beg]);
    sort(arr, beg, l);
    sort(arr, r, end);
  }
}
\end{lstlisting}

当我们需要高亮Java代码，不需要行号，不需要边框时，可以：
\begin{lstlisting}[language=Java,numbers=none,frame=none]
// A program to display the message
// "Hello World!" on standard output

public class HelloWorld {
 
   public static void main(String[] args) {
      System.out.println("Hello World!");
   }
      
}   // end of class HelloWorld
\end{lstlisting}

细心的用户可能发现，行号被放在了正文框之外，事实上这样是比较美观的，
如果有些用户希望在正文框架之内布置所有内容，可以：
\begin{lstlisting}[language=perl,xleftmargin=2em,framexleftmargin=1.5em]
#!/usr/bin/perl
print "Hello, world!\n";
\end{lstlisting}

好了，就这么多，\texttt{listings}宏包的功能很强大也很复杂，如果需要自己定制，
可以查看其手册，耐心阅读总会找到答案。
\textbf{注意:} 当前代码环境中文注释的处理还不是很完善，对于注释请妥善处理。
在本模板中，推荐算法环境或者去掉中文的listings代码环境。
如果需要包含中文注释，不要求代码高亮，
就用\texttt{code}环境，这个环境是Verbatim的定制版，简单有效，
调用的是fancyvbr宏包，用户可在mynudt.sty中修改它的外观等等。
这里我们还可以给代码加上标签。
\begin{code}[label=hello.c]
public class HelloWorld {
   public static void main(String[] args) {
      System.out.println("Hello World!");
   }
}   // 世界，你好！
\end{code}

\section{符号列表}

{\hei 前面的话：}{\kai\color{blue} 
2.2版本后默认使用nomencl环境，如果你还是希望使用传统的\verb|definition.tex|，那么只需注释掉
顶层文件中的nomenclature即可。}

符号列表使用的是\verb|nomencl|包，自己简单定制了下，使用方法分为四步：
\begin{compactenum}
\item 将\verb|\makenomenclature|语句放在正文前，即\verb|\begin{document}|前面；
\item 将\verb|\printnomenclature|放在论文中，我在例子中将符号列表放在了英文摘要的
后面，正文第一章的前面，当然，你可以根据自己的需要或者教研室的规范放置在合理的位置上，
为了页面引用的正确，在这句话前面放上\verb|\cleardoublepage|；
\item 使用\verb|\nomenclature|命令在论文的各个位置上添加符号定义，语法后面会讲到；
\item 编译。编译需要首先运行一遍xelatex，之后运行
\begin{code}
makeindex -s nomencl.ist -o thesis.nls thesis.nlo
\end{code}
\end{compactenum}

你可以把这句编译命令放在\verb|makepdf.bat|中第一个\verb|xelatex thesis|下面。然后
双击\verb|makepdf.bat|就可以了，论文模板中已经为你添加上了，如果你强烈不想使用
nomencl环境，只要把它注释掉（前面加\verb|rem|）就可以。
另外，由于我使用的是VIM来编辑\TeX{}代码，具体到每个编辑器（诸如WinEDT，TeXWorks等）
如何设定该命令的快捷按钮，诸位可以搜索网上的教程。

下面简单说明下\verb|\nomenclature|命令，语法为。这里插入一些随机的文字，希望
对你在阅读帮助中的思维没有什么不良的影响。
\begin{code}
\nomenclature[<prefix>]{<symbol>}{<desc>}{<null>}
\end{code}
\verb|nomencl|模板的默认排序方法可能（大多都）不满足要求，
论文模板里，我们通过设定\verb|<prefix>|来实现符号列表的排序。
它分为两部分，比如如\verb|[Aa]|，第一个字母的含义是：
\begin{compactitem}
\item[`A'] 符号归为拉丁字母
\item[`G'] 希腊字母
\item[`X'] 上标
\item[`Z'] 下标
\end{compactitem}
每个标识后边的字幕\verb|a-z|作为当前符号组内的排列顺序，比如$\beta$就可以写成
\verb|[Gb]|，诸如此类。当然你一定注意到了，这个排序分组的设定只是为了记忆
方便，并不是强制的，因此你可以有自己的方案，比如Z是Greek，
R是Roman什么的，只要统一就好，只需记住，组间排列是按字母顺序排的。

注意符号表分四列，前三列的含义与命令中相同，
最后一列是符号定义时所在的页码。效果看例子，对于下式:
\begin{equation}\label{eq:heatflux}
   \dot{Q} = k \cdot A \cdot \Delta T
\end{equation}%
\nomenclature[Aq]{$\dot{Q}$}{heat flux}{}%
\nomenclature[Ak]{$k$}{overall heat transfer coefficient,式\eqref{eq:ohtc}}{}%
\nomenclature[Aa]{$A$}{area}{}%
\nomenclature[Al]{$L$}{length}{}%
\nomenclature[At]{$T$}{temperature}{}%
\nomenclature[At]{$\Delta T$}{temperature difference}{}%
\nomenclature[Gr]{$\gamma$}{中文测试, 以及一句很长的物理意义，很有可能超过当前栏的宽度，主要目的是看一看会不会出现某些异常情况。}{}%

或者:
\begin{equation}\label{eq:ohtc}
    \frac{1}{k} = \left[\frac{1}{\alpha _{\mathrm{i}}\,r_{\mathrm{i}}} +
    \sum^n_{j=1}\frac{1}{\lambda _j}\,
    \ln \frac{r_{\mathrm{a},j}}{r_{\mathrm{i},j}} +
    \frac{1}{\alpha _{\mathrm{a}}\,
    r_{\mathrm{a}}}\right] \cdot r_{\mathrm{reference}}
\end{equation}%
\nomenclature[Ga]{$\alpha$}{convection heat transfer coefficient}{}%
\nomenclature[Zi]{i}{in}{}%
\nomenclature[Gl]{$\lambda$}{thermal conductivity}{}%
\nomenclature[Za]{a}{out}{}%
\nomenclature[Zn]{$n$}{number of walls}{}%
\nomenclature[Zj]{$j$}{running parameter}{}%

{\hei 注意事项：}{\kai 模板中定制的nomencl格式在mynudt.sty中，默认是三栏的，分别是：
``符号''，``定义''，``首次出现页码''，
注意这里的符号列表都没有单位，如果你需要额外的栏输入单位（呵呵，聪明的读者可能看出来
了，\verb|nomenclature|命令最后一个是空的，就是用来让你赋予她各种意义的）。
此时就需要你有一点点动手能力了（其实只要会修改表格就行），
方法很简单，比如需要添加``国际单位制''这一栏，则
\begin{compactenum}
\item 论文中\verb|\nomenclature|命令的第三个参数就让他代表单位，也可留空；
\item 将\verb|mynudt.sty|中longtable的表头添加``国际单位制''几个字，
你也可以取其他的名字，放在那个{\kai 应该出现的}位置上；
\item 由于增加了5个字，就把前面栏的宽度数字减5，同时设定第三栏宽度为5，
注意这一步需要你自己调整，记得不要让表格超出边界就行。
\end{compactenum}
}

\section{中文习惯}
\label{sec:chinese}

对于itermize过大的行间距，用户可以使用compactitem环境来替代，但是模板中不进行默认替代，
因为只有用户真正发现列表不好看才会找到这里，而且在示例文件中，
陈赓大将那个列表环境如果压缩了行距会很不好看。谢谢ZhangLei的建议！

{\hei 一个重要的提示：}
作者自己的定义命令、包等，不要放在模板里面，请放到\verb|mynudt.sty|
中，这样模板时，只要覆盖\verb|nudtpaper.cls|即可。

中文破折号为一个两个字宽垂直居中的直线，输入法直接得到的破折号是两个断开的小短线
（——），这看起来不舒服。所以模板中定义了一个破折号的命令 \verb|\pozhehao|，请看：

厚德博学，强军兴国\hfill \pozhehao{}国防科大校训
}

